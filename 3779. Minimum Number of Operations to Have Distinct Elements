// Contest question: biweekly 172
// brute force: 
class Solution {
public:
    int minOperations(vector<int>& nums) {
        int n = nums.size();
        unordered_map<int, int> map;
        int dp = 0;
        for (auto num : nums) {
            map[num]++;
            if (map[num] == 2)
                dp++;
        }

        //  3 8 3 6 5 8
        // 1 1 1 1 2 2 3
        //  3->2
        //  8->2
        //  6->1
        //  5->1 dp=2

        int count = 0;
        int idx = 0;
        
        while (idx < n && dp > 0) {
            for (int i = 0; i < 3 && idx < n; i++) {
                int val = nums[idx]; //3 8 3
                map[val]--;//3->1 8->1 3->0

                if (map[val] == 1) {
                    dp--;
                }                           //dp=1 dp=0
                if (map[val] == 0) {
                    map.erase(val);  //3->removed
                }
                idx++;//idx=1 idx=2 idx=3
            }
            count++;//1
        }
        return count;
    }
};


// Optimized: 
class Solution {
public:
    int minOperations(vector<int>& nums) {
        unordered_set<int> set;
        int n = nums.size();
        int i;
        for (i = n - 1; i >= 0; i--) {
            if (set.count(nums[i]))
                break;
            set.insert(nums[i]);
        }
        return (i + 3) / 3;
    }
};
