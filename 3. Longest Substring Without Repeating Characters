// Brute Force: 
/*
- generate all substrings
- hash them as you gen them
- compare length & check for repeat via hashing... t t
*/
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int maxlen = 0; 
        for (int i = 0; i < s.size(); i++) {
            vector <int> hash (256, 0); 
            for (int j = i; j < s.size(); j++) {
                if (hash[s[j]] == 1) break; 
                hash[s[j]] = 1; 
                int len = j - i + 1; 
                maxlen = max(len, maxlen); 
            }
        }
        return maxlen; 
    }
};
// Better/Optimized: Two Pointer
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        vector <int> hash (256, -1); 
        int n = s.size(); 
        int l = 0, r = 0; 
        int maxlen = 0; 
        while (r < n) {
            if (hash[s[r]] != -1) {
                if (hash[s[r]] >= l) {
                    l = hash[s[r]] + 1; 
                }
            }
            int len = r - l + 1;
            maxlen = max(len, maxlen); 
            hash[s[r]] = r; 
            r++; 
        }
        return maxlen; 
    }
};
