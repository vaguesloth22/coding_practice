// Brute Force: 
class Solution {
public:
    void bst(TreeNode * node, TreeNode * x, vector<TreeNode*> &temp) {
        if (node == nullptr) {
            return; 
        }
        temp.push_back(node); 
        if (node == x) {
            return; 
        }
        if (x->val < node->val) {
            bst(node->left, x, temp); 
        }
        else {
            bst(node->right, x, temp); 
        }
    }
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        vector<TreeNode*> ans1; 
        vector<TreeNode*> ans2; 

        bst(root, p, ans1); 
        bst(root, q, ans2); 
        int i = 0; 
        while (i < ans1.size() && i < ans2.size() && ans1[i] == ans2[i]) {
            i++;
        }
        return ans1[i-1]; 
    }
};
// Better Approach: 
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if (root == nullptr) return nullptr; 
        int curr = root->val; 
        if (curr < p->val && curr < q->val) {
            return lowestCommonAncestor(root->right, p, q); 
        }
        if (curr > p->val && curr > q->val) {
            return lowestCommonAncestor(root->left, p, q); 
        }
        return root; 
    }
};
